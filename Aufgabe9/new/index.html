<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>EA9 - Torus mit Textur</title>
  <style>body { margin:0; }</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
// Übergibt die UV-Koordinaten an den Fragment-Shader
varying vec2 vUV;

void main() {
  vUV = uv;  // UV-Koordinaten aus der Geometrie weitergeben
  // Transformation der Position in Clip-Space
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
// Empfang der UV-Koordinaten vom Vertex-Shader
varying vec2 vUV;

void main() {
  float scale = 20.0; // Anzahl der Streifen auf dem Torus
  // Erzeugt scharfe Streifen anhand der UV-x-Koordinate
  float stripes = step(0.5, fract(vUV.x * scale));
  vec3 color1 = vec3(1.2, 2.6, 4.9); // Erste Farbe (evtl. Werte >1, HDR)
  vec3 color2 = vec3(4.9, 2.9, 0.2); // Zweite Farbe
  // Mische die beiden Farben je nach Streifenmuster
  vec3 col = mix(color1, color2, stripes);
  // Setzt die Fragmentfarbe mit Alpha 2.0 (außerhalb Üblicher Bereich)
  gl_FragColor = vec4(col, 2.0);
}
</script>

<script>
  // Erstelle die Szene, Kamera und Renderer
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.z = 3;  // Kamera etwas nach hinten positionieren

  const renderer = new THREE.WebGLRenderer({antialias:true}); // Aktiviert Kantenglättung
  renderer.setSize(window.innerWidth, window.innerHeight);   // Fenstergröße setzen
  document.body.appendChild(renderer.domElement);           // Renderer-Canvas ins Dokument hängen

  // Geometrie des Torus mit 32 Segmente um Querschnitt und 64 Segmente um Kreis
  const geometry = new THREE.TorusGeometry(1, 0.3, 32, 64);

  // ShaderMaterial mit eigenen Vertex- und Fragment-Shadern
  const material = new THREE.ShaderMaterial({
    vertexShader: document.getElementById('vertexShader').textContent,
    fragmentShader: document.getElementById('fragmentShader').textContent,
  });

  // Mesh aus Geometrie und Material erzeugen
  const torus = new THREE.Mesh(geometry, material);
  scene.add(torus); // Torus zur Szene hinzufügen

  // Animationsfunktion: Dreht den Torus und rendert die Szene
  function animate() {
    requestAnimationFrame(animate);  // Animationsloop
    torus.rotation.y += 0.01;        // Rotation um Y-Achse
    renderer.render(scene, camera);  // Szene rendern
  }

  animate(); // Animationsstart

  // Fenstergrößenänderung behandeln (Responsivität)
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight; // Seitenverhältnis aktualisieren
    camera.updateProjectionMatrix();                      // Projektionsmatrix aktualisieren
    renderer.setSize(window.innerWidth, window.innerHeight); // Renderer anpassen
  });
</script>

</body>
</html>
